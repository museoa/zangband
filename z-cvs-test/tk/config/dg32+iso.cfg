# File: dg32+iso.cfg

# Purpose: icon configuration file

#
# Copyright (c) 1997-2001 Tim Baker
#
# This software may be copied and distributed for educational, research, and
# not for profit purposes provided that this copyright and statement are
# included in all such copies.
#

### You must call "angband init_icons" to initialize the icon
### environment. The argument is the size of icons to use,
### either 16 or 32.
NSConfig::InitIcons 32

Global iconStyle iso
icon style iso

# This is a list of type names for David E. Gervais' graphics.
# The actual file name is derived from the type name.

### Trasparent icons
set data [list \
	armor effects food classm humans \
	jewls magic misc potions wands \
	weapons people dragon monster1 monster2 \
	monster3 monster4 monster5 monster6 monster7 \
	undead uniques
]

# Create each icon type
foreach iconType $data {

	# Build the gif file name
	set gif dg_${iconType}32.gif

	# The masks are generated automatically from the white pixels
	set mask $gif:makeMask

	# Load the icon data
	NSConfig::CreateIconType $iconType $gif $mask 32

	# Synch icon data with mask data
	NSConfig::Maskify $iconType
}

### Non-masked icons
set data [list \
	town0 \
]

# Create each icon type
foreach iconType $data {

	# Build the gif file name
	set gif dg_${iconType}32.gif

	# Not transparent
	set mask {}

	# Load the icon data
	NSConfig::CreateIconType $iconType $gif $mask 32
}

	icon createtype dynamic -height 49 -width 54 -dynamic yes
	icon rle dynamic #00FFFF
	icon dynamic count dynamic 23

### Non-masked icons
set data [list \
	iso \
]

# Create each icon type
foreach iconType $data {

	set gif dg_${iconType}32.gif

	# FIXME: Hard-coded from NSConfig since width/height/rle not supported

	set imageFile [NSConfig::FindImageFile $gif]

	set iconData dg_${iconType}32.[icon depth].icd
	set iconData [NSConfig::FileLibData $iconData]
	set makeicon 1
	if {[file exists $iconData]} {
		set mtime [file mtime $imageFile]
		set mtime2 [file mtime $iconData]
		if {$mtime < $mtime2} {
			set makeicon 0
		}
	}
	if {$makeicon} {
		angband_load prompt "Writing icon file \"[file tail $iconData]...\""
		icon makeicon -iconwidth 54 -iconheight 49 \
			-imagefile $imageFile -datafile $iconData
	}
	icon createtype $iconType -file $iconData -width 54 -height 49
	icon rle $iconType #00FFFF
}

# Use Adam Bolt's 32x32 graphics for monsters
NSConfig::CreateIconType adam adam16.gif adam16.gif:makeMask 16

# Synch icon data with mask data
NSConfig::Maskify adam

# NOT ISO
#	NSConfig::CreateIconType pattern pattern16.gif "" 16


# The "town" icon type
# NOT ISO
#	NSConfig::CreateIconType town town32.gif "" 32


NSConfig::SourceOne classic-common

# Hack
NSConfig::NoMoreIcons

# The "town" file is shared by all xxx.cfg files
NSConfig::ShareConfigFile town town

# Assign an icon to each flavored object
NSConfig::SourceOne config-flavor

# Assign pile icon to "object 0"
assign set object 0 "icon misc 54"

# Assign an icon to the character
NSConfig::SourceOne config-char

qebind DGHack <Dungeon-enter> {DGHackProc %c}

qebind DGHack <Dungeon-generate> {
	if {%c && (%c == [Global dghack,depth])} {
		Global dghack,depth -1
	}
}

Global dghack,depth -1
Global dghack,which -1

proc constList {args} {

	set result {}
	foreach name $args {
		lappend result [const $name]
	}
	return $result
}

proc DGHackProc {depth} {

	set feats [constList FEAT_WALL_EXTRA FEAT_PERM_EXTRA FEAT_MAGMA FEAT_QUARTZ \
		FEAT_MAGMA_K FEAT_QUARTZ_K]

	# Light smooth
	lappend wall 71
	lappend single 70
	lappend floor 13
	lappend door 93
	lappend stair 99

	# Light rough
	lappend wall 82
	lappend single 70
	lappend floor 13
	lappend door 93
	lappend stair 99

	# Dark smooth
	lappend wall 102
	lappend single 101
	lappend floor 13
	lappend door 124
	lappend stair 130

	# Dark rough
	lappend wall 113
	lappend single 101
	lappend floor 15
	lappend door 124
	lappend stair 130

	# Tan smooth
	lappend wall 133
	lappend single 132
	lappend floor 11
	lappend door 155
	lappend stair 161

	# Tan rough
	lappend wall 144
	lappend single 132
	lappend floor 11
	lappend door 155
	lappend stair 161

	# 1-6 are shaped, 7-10 are not
	set which [expr int(rand() * 10)]

	# Force white smooth (shapeless) brick in town
	if {!$depth} {
		set which 9
	}

	if {$depth && ([Global dghack,depth] == $depth)} {
		set which [Global dghack,which]
	}

	# Darkness
	scan [assign set feature 0] "%s %s %d" icon darkType darkIndex
	if {[icon dark $darkType $darkIndex] != "1.0 1.0"} {
		icon dark $darkType $darkIndex 1.0 1.0
	}

	set shapes [list ns we corner_nw corner_ne corner_sw corner_se \
		tri_n tri_w tri_e tri_s quad]

	if {$which < 6} {

		set wall [lindex $wall $which]
		set single [lindex $single $which]
		set floor [lindex $floor $which]
		set door [lindex $door $which]
		set stair [lindex $stair $which]

		assign set feature [const FEAT_FLOOR] "icon iso $floor"

		set offsets [list 0 1 5 2 4 3 7 6 8 9 10]
		set j 0
		foreach shape $shapes offset $offsets {
			icon dynamic blank dynamic $j
			icon dynamic copy dynamic $j -type iso -index $floor
			icon dynamic copy dynamic $j -type iso -index [expr {$wall + $offset}]
			set dynamic($shape) $j
# outer
set k [expr {11 + $j}]
icon dynamic blank dynamic $k
icon dynamic copy dynamic $k -type iso -index $darkIndex ; # unknown
icon dynamic copy dynamic $k -type iso -index [expr {$wall + $offset}]
set dynamic($shape,outer) $k
			incr j
		}

		foreach f_idx $feats {

			# Not necessary
			assign set feature $f_idx "icon default 0"

			feature assignshape $f_idx single "icon iso $single"
			foreach shape $shapes {
				feature assignshape $f_idx $shape "icon dynamic $dynamic($shape)"
# outer
feature assignshape $f_idx $shape "icon dynamic $dynamic($shape,outer)" hack
			}

			# Background is self
			feature configure $f_idx -background $f_idx
		}
	}

	if {$which >= 6} {

		if {$which == 6} {

			# Brown stalagmite
			set wall 56

			# Brown floor
			set floor 55

			# Wood door
			set door 64
			
			set stair 161 ; # tan

		} elseif {$which == 7} {

			# Black stalagmite
			set wall 59

			# Black floor
			set floor 15

			# Black door
			set door 124

			# Black stair
			set stair 130

icon dark iso $floor .9 .8

		} elseif {$which == 8} {

			# Dark block
			set wall 101

			# Brown floor
			set floor 55

			# Wood door
			set door 124

			# Black stair
			set stair 130

		} else {

			# White block
			set wall 70

			# Light
			set floor 13

			# White door
			set door 93

			# White stair
			set stair 99
		}

		foreach f_idx $feats {

			# Shapeless
			feature assignshape $f_idx single "icon default 0"
			foreach shape $shapes {
				feature assignshape $f_idx $shape "icon default 0"
# outer
feature assignshape $f_idx $shape "icon default 0" hack
			}

			# Same icon for each wall type
			assign set feature $f_idx "icon iso $wall"

			# Background is self
			feature configure $f_idx -background $f_idx
		}

		assign set feature [const FEAT_FLOOR] "icon iso $floor"
	}

	set f_idx [const FEAT_OPEN]
	assign set feature $f_idx "icon default 0"
	feature assignshape $f_idx ns "icon iso $door"
	feature assignshape $f_idx we "icon iso [expr $door + 1]"

	set f_idx [const FEAT_BROKEN]
	assign set feature $f_idx "icon default 0"
	feature assignshape $f_idx ns "icon iso [expr $door + 4]"
	feature assignshape $f_idx we "icon iso [expr $door + 5]"

	set f_idx [const FEAT_DOOR_HEAD]
	assign set feature $f_idx "icon default 0"
	feature assignshape $f_idx ns "icon iso [expr $door + 2]"
	feature assignshape $f_idx we "icon iso [expr $door + 3]"

	# Up stair
	assign set feature [const FEAT_LESS] "icon iso $stair"

	# Down stair
	assign set feature [const FEAT_MORE] "icon iso [expr $stair + 1]"

	# Quest entrances/exits
	foreach f_idx [list [const FEAT_QUEST_EXIT] [const FEAT_QUEST_UP]] {
		assign set feature $f_idx "icon iso $stair"
	}
	foreach f_idx [list [const FEAT_QUEST_ENTER] [const FEAT_QUEST_DOWN]] {
		assign set feature $f_idx "icon iso [expr {$stair + 1}]"
	}


	# Tree
	if {$depth} {
		set tree 48
	} else {
		set assign [assign set feature [const FEAT_GRASS]]
		scan $assign "%s %s %d" type type floor
		set tree 47
	}
	set j [expr {[icon count dynamic] - 1}]
	icon dynamic blank dynamic $j
	icon dynamic copy dynamic $j -type iso -index $floor
	icon dynamic copy dynamic $j -type iso -index $tree
	assign set feature [const FEAT_TREES] "icon dynamic $j"

	for {set i 0} {$i < [icon count dynamic]} {incr i} {
		icon dark dynamic $i 0.9 0.8
	}

	# Remember which icons were chosen.
	if {$depth} {
		Global dghack,which $which
		Global dghack,depth $depth
	}

	return
}


# When entering a town, see if a vault file for that town exists and
# read it in. This requires some knowledge of the t_info.txt file for
# determining which town file (and therefore which vault file) is used.

proc VaultCurrentProc {depth} {

	# Unset the current vault
	vault current 0

	if {$depth} return
	if {[struct set player_type 0 inside_arena]} return
	if {[struct set player_type 0 inside_quest]} return

	set town_num [struct set player_type 0 town_num]
	if {!$town_num} return

	switch -- $town_num {
		1 {
			if {[angband setting set vanilla_town]} {
				set name t_basic
			} elseif {[angband setting set lite_town]} {
				set name t_lite
			} else {
				set name t0000001
			}
		}
		default {
			set name t000000$town_num
		}
	}
	append name -[Global config,prefix].vlt
	set path [PathTk config $name]
	if {[file exists $path]} {
		vault current [Global vault,current]
		vault read [vault current] $path
	}

	return
}

# When entering a level, see if a custom .vlt file exists
qebind VaultCurrent <Dungeon-enter> {VaultCurrentProc %c}




for {set i 0} {$i < [icon count iso]} {incr i} {
	icon dark iso $i 0.9 0.8
}

# Darkness
assign set feature 0 "icon iso 208"
icon dark iso 208 1.0 1.0

# Doors
foreach i {64 68 93 97 124 128 155 159} {
	icon flag iso $i left yes
}
foreach i {65 69 94 98 125 129 156 160} {
	icon flag iso $i right yes
}

# Mark certain isometric icons as "non-transparent"
for {set i 0} {$i <= 33} {incr i} {
	icon flag iso $i isohack yes
}
for {set i 39} {$i <= 43} {incr i} {
	icon flag iso $i isohack yes
}
for {set i 55} {$i <= 63} {incr i} {
	icon flag iso $i isohack yes
}
icon flag iso 70 isohack yes
icon flag iso 101 isohack yes
icon flag iso 132 isohack yes

